replicas: 4 - количество подов, которые будут запущены. В соответствии с результатами нагрузочного теста, 4 пода справляются с пиковой нагрузкой. Количество подов регулируется HPA.
selector: matchLabels: app: - селекторы для выбора подов, которые должны быть частью этого деплоя.
template: metadata: labels: app: - метки, которые будут добавлены к каждому поду в этом деплое.
containers: - name:  image:  - имя контейнера, который будет запущен в каждом поде.
ports: - containerPort: - порт, который будет открыт в каждом поде.
resources: requests: memory: 128Mi cpu: 0.1 - запросы на ресурсы, которые будут сделаны каждым подом.
resources: limits: memory: 128Mi cpu: 0.2 - лимиты ресурсов, которые будут установлены для каждого пода.
readinessProbe: httpGet: path: initialDelaySeconds: 5 periodSeconds: 5 -  будет проверять, готов ли под к приёму запросов.
livenessProbe: httpGet: path:  initialDelaySeconds: 10 periodSeconds: 10 -  будет проверять, жив ли под.
strategy: type: RollingUpdate rollingUpdate- стратегия обновления деплоя. используется стратегия которая позволяет обновлять деплой поэтапно, не прерывая работу приложения.
podAntiAffinity: позволяет запускать каждый под в отдельной ноде

**Объяснение:**
Количество подов: исходя из результатов нагрузочного теста, 4 пода справляются с пиковой нагрузкой. При этом в мультизональном кластере с пятью нодами, можно запустить три пода в каждой зоне, что повысит отказоустойчивость приложения.
Ресурсы: на первые запросы приложению требуется значительно больше ресурсов CPU, в дальнейшем потребление ровное в районе 0.1 CPU. По памяти всегда “ровно” в районе 128M memory. В связи с этим, для запросов заданы запросы на ресурсы, равные реальным потребностям приложения, а лимиты заданы выше, чтобы обеспечить возможность пиковой нагрузки.
Отказоустойчивость: для повышения отказоустойчивости, используется стратегия обновления деплоя "RollingUpdate", которая позволяет обновлять деплой поэтапно, не прерывая работу приложения.
Минимальное потребление ресурсов: для минимизации потребления ресурсов, используются ресурсы только в том количестве, которое необходимо приложению.
Для минимального потребления ресурсов в часы низкой нагрузки можно использовать стандартный автоскейлер или KEDA автоскейлер если установлен KEDA. 
https://artifacthub.io/packages/helm/kedacore/keda
Приемущества KEDA - можно скейлить в 0. Дает максимальную экономию по ресурсам. Но для этого нужны дополнительные метрики например Prometheus. 
https://artifacthub.io/packages/helm/ingress-nginx/ingress-nginx
Для максимальной отказоустойчивости нам нужно будет также создать service для deployment и ingress для этого service. 
Для ingress нужно установить ingress-nginx